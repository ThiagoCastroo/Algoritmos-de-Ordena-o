Comparação de Desempenho: Uma Análise de Algoritmos de Ordenação

## Resumo

Este projeto realiza uma análise detalhada de vários algoritmos de ordenação, incluindo Bubble Sort, Insertion Sort, Selection Sort, Merge Sort e Quick Sort. 
O estudo avalia o tempo de execução de cada algoritmo utilizando vetores de entrada gerados aleatoriamente para garantir consistência nos testes. 
O objetivo principal é fornecer uma compreensão clara e aprofundada das características e eficiências de cada algoritmo de ordenação, auxiliando na seleção da abordagem mais adequada para diferentes cenários computacionais.

## Tabela de Conteúdos

- [Introdução](#introdução)
- [Desvendando a Notação Big O](#desvendando-a-notação-big-o)
- [Algoritmos de Ordenação](#algoritmos-de-ordenação)
- [Metodologia](#metodologia)
- [Resultados](#resultados)
- [Referências](#referências)

## Introdução

Por que ordenar dados importa? Neste artigo foi realizada uma análise de vários algoritmos de ordenação, incluindo Bubble Sort, Insertion Sort, Selection Sort, Merge Sort e Quick Sort. 
O estudo busca compreender e comparar o desempenho de cada algoritmo, visando fornecer uma compreensão clara e aprofundada das características e eficiências de cada um.

## Desvendando a Notação Big O

A notação Big O serve como um termômetro para medir o comportamento dos algoritmos à medida que a quantidade de dados aumenta. 
Ela nos ajuda a prever o desempenho de um algoritmo e entender seu comportamento em diferentes tamanhos de conjuntos de dados.

## Algoritmos de Ordenação

- **Bubble Sort**: Complexidade de tempo O(n²). Não é eficiente para listas grandes.
- **Selection Sort**: Complexidade de tempo O(n²). Mantém duas partes na lista: a parte ordenada e a parte não ordenada.
- **Insertion Sort**: Complexidade de tempo O(n²). Funciona bem para listas pequenas ou quase ordenadas.
- **Shell Sort**: Complexidade de tempo O(n²) em alguns casos. Superou outros algoritmos clássicos em eficiência para muitos conjuntos de dados.
- **Quick Sort**: Complexidade de tempo médio de O(n log n), mas pode chegar a O(n²) no pior caso.
- **Merge Sort**: Complexidade de tempo O(n log n). Eficiente para ordenar listas grandes de forma rápida e consistente.

## Metodologia

### Descrição do Ambiente de Testes

Os testes foram realizados em um computador com processador Intel(R) Core(TM) i5–8250U CPU @ 1.60GHz, memória RAM de 8,00 GB e sistema operacional Windows 10 Home.

### Critérios de Avaliação

Os critérios incluíram tempo de execução dos algoritmos para diferentes tamanhos de entrada e a quantidade de comparações realizadas durante o processo de ordenação.

## Resultados

- **Bubble Sort**: Apresentou os piores tempos de execução em todos os tamanhos de vetores testados.
- **Selection Sort**: Desempenho ruim, com tempos de execução próximos ao Bubble Sort.
- **Insertion Sort**: Um pouco mais rápido que o Bubble Sort e o Selection Sort, mas ainda insatisfatório para listas maiores.
- **Shell Sort**: Mais rápido que os algoritmos anteriores, com uma melhora significativa no desempenho.
- **Quick Sort**: Apresentou os melhores tempos de execução na maioria dos casos.
- **Merge Sort**: Desempenho impressionante em todos os tamanhos de vetores testados.

## Referências

- [Bibliotecas utilizadas](
https://devdocs.io/cpp/header/iostream
https://devdocs.io/cpp/header/cstdlib
https://devdocs.io/cpp/header/vector
https://devdocs.io/cpp/header/ctime)
- [Algoritmos de ordenação explicados](https://www.freecodecamp.org/portuguese/news/algoritmos-de-ordenacao-explicados-com-exemplos-em-python-java-e-c/)
- [Repositório GitHub](https://github.com/mateusArnaudGoldbarg/ED/blob/main/ed.cpp)
- [Referências de mídia](https://commons.wikimedia.org/wiki/Main_Page)
